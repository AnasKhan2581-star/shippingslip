<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Crypto Ascending Triangle Breakout Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: Arial, sans-serif; background: #111; color: #f5f5f5; margin: 0; padding: 0; }
    header { background: #181d23; padding: 16px; text-align: center; font-size: 1.2em; letter-spacing: 2px; }
    #results { margin: auto; max-width: 970px; background: #20232a; padding: 20px; border-radius: 10px; margin-top: 30px; }
    table { width: 100%; border-collapse: collapse; }
    td, th { padding: 10px; border-bottom: 1px solid #333; text-align: center; }
    th { background: #23272f; }
    .alert { color: #9f0; }
    #status { margin: 20px; color: #0ca; }
    .loading { color: #fe6; font-size: 1em; margin: 10px 0; }
    .notif-enabled { color: #0f0; }
    .notif-disabled { color: #f99; }
    .row-highlight { background: #262b33; }
  </style>
</head>
<body>
  <header>
    Crypto Ascending Triangle Breakout Scanner<br>
    <span style="font-size:0.7em; color:#ef6;">(Top 200 Gainers, auto-scan every 10 min)</span>
  </header>
  <div id="status"></div>
  <div id="results">
    <div class="loading" id="loading">Loading data and scanning coins...</div>
    <table id="coins" style="display:none;">
      <thead>
        <tr>
          <th>Coin</th>
          <th>Triangle Resistance</th>
          <th>Last Price</th>
          <th>Details</th>
          <th>Breakout?</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <script>
    const INTERVAL = "5m";
    const KLINES = 120;     // Candles per symbol (approx. 10h for 5m)
    const SCAN_INTERVAL = 10 * 60 * 1000; // 10 minutes
    let lastNotifications = new Set();
    let notifEnabled = false;

    async function fetchTopGainers(limit = 200) {
      const tickers = await fetch("https://api.binance.com/api/v3/ticker/24hr").then(r=>r.json());
      const usdt = tickers.filter(x =>
        x.symbol.endsWith("USDT") &&
       (!x.symbol.startsWith("USDC") && !x.symbol.startsWith("TUSD") && !x.symbol.startsWith("BUSD") && !x.symbol.endsWith("FDUSD"))
        && parseFloat(x.priceChangePercent)>0
      );
      usdt.sort((a,b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent)); // sort by % gain
      return usdt.slice(0, limit).map(x=>x.symbol);
    }

    async function fetchKlines(symbol, interval=INTERVAL, limit=KLINES) {
      const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      const result = await fetch(url);
      if (!result.ok) return [];
      const klines = await result.json();
      return klines.map(k=>({
        open: +k[1],
        high: +k[2],
        low: +k[3],
        close: +k[4],
        volume: +k[5]
      }));
    }

    // Helper to find if price is in downtrend before the triangle
    function detectDowntrend(klines, bars=28) {
      if (klines.length < bars+10) return false;
      return klines[klines.length-bars-10].high > klines[klines.length-bars].high
          && klines[klines.length-1].close < klines[klines.length-bars].close;
    }

    // Helper to detect ascending triangle in last N bars
    function detectAscendingTriangle(klines, lookback=50, minBounces=2) {
      if (klines.length < lookback+6) return null;
      const closes = klines.slice(-lookback).map(x=>x.close);
      const highs = klines.slice(-lookback).map(x=>x.high);
      const lows = klines.slice(-lookback).map(x=>x.low);

      // Flat resistance as the most common high in last 1/3 of lookback
      const res = highs.slice(Math.floor(lookback*2/3));
      const histogram = {};
      res.forEach(val => {
        let v = Number(val.toFixed(4));
        histogram[v] = (histogram[v]||0)+1;
      });
      // The most repeated high is resistance
      let res_y = +Object.keys(histogram).sort((a,b)=>histogram[b]-histogram[a])[0] || highs[highs.length-1];

      // Find at least two rising lows (higher lows)
      let lowsIdx = [];
      for(let i=1;i<lows.length-1;i++){
        if(lows[i] < lows[i-1] && lows[i] < lows[i+1]){
          lowsIdx.push(i);
        }
      }
      let higherLows = [];
      for(let i=1;i<lowsIdx.length;i++){
        if(lows[lowsIdx[i]] > lows[lowsIdx[i-1]]){
          higherLows.push({i: lowsIdx[i], price: lows[lowsIdx[i]]});
        }
      }
      if(higherLows.length < minBounces-1) return null;

      // Apex: last 5 closes are close to resistance (within 0.1%)
      let nearRes = closes.slice(-5).filter(c=>Math.abs(1 - c/res_y) < 0.001);
      if(nearRes.length<3) return null;

      return {resistance: res_y, higherLows};
    }

    function isVolumeRising(klines, window=10){
      const vol = klines.slice(-window).map(x=>x.volume);
      let avgEarly = vol.slice(0,Math.floor(window/2)).reduce((a,b)=>a+b,0)/Math.floor(window/2);
      let avgLate  = vol.slice(Math.floor(window/2)).reduce((a,b)=>a+b,0)/(window-Math.floor(window/2));
      return avgLate > avgEarly*1.15; // 15% increase or more
    }

    function notifyBreakout(symbol, info) {
      if (lastNotifications.has(symbol)) return;
      if (notifEnabled) {
        let body = `Ascending triangle detected at ${info.resistance}, volume rising.`;
        new window.Notification(`Breakout Alert: ${symbol}`, { body });
      }
      lastNotifications.add(symbol);
    }

    async function scanCoins() {
      document.getElementById('loading').textContent = "Scanning top gainers, please wait...";
      const tableBody = document.querySelector("#coins tbody");
      tableBody.innerHTML = "";
      lastNotifications.clear();
      const symbols = await fetchTopGainers();
      let anyFound = false;

      // Limit parallel fetches to ~6 at a time for rate limits
      function chunk(arr,n){return arr.reduce((acc,x,i)=>(acc[Math.floor(i/n)].push(x),acc),Array.from({length:Math.ceil(arr.length/n)},()=>[]))};
      const batches = chunk(symbols, 7);
      for(const batch of batches){
        await Promise.all(batch.map(async symbol=>{
          const klines = await fetchKlines(symbol);
          if(klines.length < 80) return;
          if(!detectDowntrend(klines,28)) return;

          const tri = detectAscendingTriangle(klines, 50, 2);
          if(!tri) return;

          if(!isVolumeRising(klines, 14)) return;

          // About to break!
          anyFound = true;
          const last = klines[klines.length-1];
          tableBody.innerHTML += `<tr class="row-highlight">
            <td><b>${symbol}</b></td>
            <td style="color:#fa6;">${tri.resistance.toFixed(5)}</td>
            <td>${last.close.toFixed(5)}</td>
            <td>
              Higher Lows: ${tri.higherLows.length+1}<br>
              Last C: ${last.close}
            </td>
            <td class="alert">YES ðŸš€</td>
          </tr>`;
          notifyBreakout(symbol, tri);
        }));
        await new Promise(res=>setTimeout(res, 1300)); // Rate limit batches
      }

      document.getElementById('loading').style.display = "none";
      document.getElementById('coins').style.display = "block";
      if(!anyFound){
        tableBody.innerHTML = `<tr><td colspan=5 style="color:#ccc;">No coins currently meet all breakout criteria.</td></tr>`;
      }
      document.getElementById('status').innerHTML = "Last scan: "+(new Date()).toLocaleTimeString()+" | Next scan in 10 min.";
    }

    // Notifications permission
    function requestNotification() {
      if (!("Notification" in window)) {
        alert("Browser does not support Notifications API.");
        return;
      }
      Notification.requestPermission().then(function(permission) {
        notifEnabled = permission==="granted";
        document.getElementById('status').innerHTML += notifEnabled
          ? ' &nbsp; <span class="notif-enabled">[Notifications enabled]</span>'
          : ' &nbsp; <span class="notif-disabled">[No notification permission]</span>';
      });
    }
    requestNotification();

    scanCoins();
    setInterval(scanCoins, SCAN_INTERVAL);
  </script>
</body>
</html>
